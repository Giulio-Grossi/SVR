ridge.r <- ridge(yv.pre, x.pre, l1, SCM = F)
dim(yv.pre)
length(yv.pre)
dim(x.pre)
ridge.r[[3]]
ridge.r
num_controls=10
t0=tt_periods
time_periods=t0 + 20
time_periods_controls <- 80
bands = 15
bands = 17
iter=6000
warm=2000
## sim pars
sp_var=.4
tt_var=0.3 ^ 2  # -GP- I reduced the tt_var a little.
ti_var=0.7 ^ 2  # -GP- I squared this to make it a variance and comparable to tt_var
bi_var=0.5 ^ 2  # -GP- I squared this to make it a variance and comparable to sp_var
tt_range=.05
sp_nugget=0.001
tt_nugget=0.15 ^ 2  # -GP- Adding some temporal nugget to the controls.
rho_error=.2
## errors def
seed_b=seed_t=seed_e=index
if(errors_sp==1){
e_weight=0  # Proportion of error that is spatial
share_error=0.4  # Noise-signal ratio (sd for error term as % of signal)
} else if(errors_sp==2){
e_weight=.5
share_error=0.4
} else if(errors_sp==3){
e_weight=.5
share_error=0.7 # -GG- : corrected mistake (21/08)
}
print(errors_sp)
#error=sqrt(.55)
#treated_radius = sort(scale(runif(bands, 0.01, 1)))
treated_radius <- seq(0, 1, length.out = bands)
treated_radius= treated_radius/max(treated_radius)
## store results over loop
method=c("SC","SR","PR", "BVR","BSC","MGP")
print(treated_radius)
#tt_range=0.01
sim=sim_model(seed_b = seed_b, seed_t = seed_t, seed_e = seed_e,
time_periods = time_periods, time_periods_controls = time_periods_controls,
bands = bands, num_controls = num_controls,
sp_var = sp_var, sp_range = sp_range, bi_var = bi_var, tt_var = tt_var,
tt_range = tt_range, ti_var = ti_var, sp_nugget = sp_nugget,
tt_nugget = tt_nugget,
e_weight = e_weight, share_error = share_error)
beta_true=sim$beta
sim=sim$sim  # The potential outcomes under control.
set.seed(index)
# Getting some quantities that are used later in the code.
num_controls <- dim(sim)[2] - bands
sim <- preset(sim, t0)$std
num_controls
yv = as.vector(sim[, 1:bands])  # As a vector over all time periods
yv.pre = as.vector(sim[1 : t0, 1 : bands])  # As a vector in pre-intervention
ym = sim[, 1 : bands]  # As a matrix over all time periods.
ym.pre = sim[1:t0, 1:bands] # As a matrix in pre-intervention.
# Getting the control unit data.
x = sim[, (bands + 1) : (num_controls + bands)]  # Matrix, all time periods
x.pre = sim[1 : t0, ((bands) + 1) : (num_controls + bands)]  # Matrix, pre-intervention
# Getting the training data, will be used in ridge only.
train = round(t0 - t0/5)
y.train = as.vector(sim[1:train, 1:bands])
x.train = sim[1:train, ((bands) + 1):(num_controls + bands)]
dim(yv)
dim(ym)
dim(ym.pre)
giulio = list()
l1 = seq(0.01,10,0.01)  # Vector of length 1000
l = tcv_ridge(sim, x , l1, train)  # Returns 1000 x 2 matrix
lam = as.numeric(subset(l, l[,2] == min(l[,2])))
l1 = lam[1]
dim(l1)
dim(lam)
dim(l)
lma
lam
ridge(yv.pre, x.pre, l1, SCM = F)
ym.pre
ridge.r <- ridge(yv.pre, x.pre, l1, SCM = F)
c.pool.rid <- ridge.r[[3]]
c.pool.rid
l1=seq(0.01,10,0.01)
l2=0
l=tcv.fused(sim,x,l1,l2, SCM=F,train)
source("Functions/tcv.fused.R")
l1=seq(0.01,10,0.01)
l2=0
l=tcv.fused(sim,x,l1,l2, SCM=F,train)
lam=subset(l, l[,3]==min(l[,3]))
lam=lam[1,1:2]
l1=lam[1]; l2=lam[2]
l1=l1;l2=0
fused.rid <- fused(yv.pre, x.pre, l1,SCM = F)
#out_path <- 'Output/1_sims/Results/'
source("Functions/fused.R")
fused.rid <- fused(yv.pre, x.pre, l1,SCM = F)
c.fus.rid <- fused.rid[[3]]
fused.rid
method
time
treated_radius
scale(treated_radius)
as.numeric(scale(treated_radius))
method
?LowRankQP
method
method
dim(x.pre)
bands
num_controls
# Getting the treated unit data:
yv = as.vector(sim[, 1:bands])  # As a vector over all time periods
yv.pre = as.vector(sim[1 : t0, 1 : bands])  # As a vector in pre-intervention
ym = sim[, 1 : bands]  # As a matrix over all time periods.
ym.pre = sim[1:t0, 1:bands] # As a matrix in pre-intervention.
# Getting the control unit data.
x = sim[, (bands + 1) : (num_controls + bands)]  # Matrix, all time periods
x.pre = sim[1 : t0, ((bands) + 1) : (num_controls + bands)]  # Matrix, pre-intervention
# Getting the training data, will be used in ridge only.
train = round(t0 - t0/5)
y.train = as.vector(sim[1:train, 1:bands])
x.train = sim[1:train, ((bands) + 1):(num_controls + bands)]
dim(x.pre)
x.pre
dim(x_matrix(x.pre))
x_matrix(x.pre)[1:3, 1:3]
x_pre[1:3, 1:3]
x.pre[1:3, 1:3]
View(x.matrix(x.pre))
View(x_matrix(x.pre))
# 6.1 pooled OLS
tx=x_matrix(x.pre)
c.pool.ols = solve(t(tx) %*% tx) %*% t(tx) %*% yv.pre
solve(t(tx) %*% tx)
yv.pre
length(yv.pre)
dim(ym.pre)
ym.pre[, 1]
eigen(t(tx) %*% tx))
eigen(t(tx) %*% tx)
eigen(t(tx) %*% tx)$val
meth0od
method
dim(x.pre)
dimnames(x.pre)
# -GP- When using
#     tx = x_matrix(x.pre)
# tx ends up being too large with way too many 0s. This is not the matrix
# we want to use as our design matrix for pooled OLS.
#
# We want to have the matrix of the controls repeated #bands times on top
# of each other. So:
tx <- x.pre
for (i in 2 : bands) {
tx <- rbind(tx, x.pre)
}
dim(tx)
c.pool.ols = solve(t(tx) %*% tx) %*% t(tx) %*% yv.pre
t(tx) %*% tx
eigen(t(tx) %*% tx)$val
lmod <- lm(yv.pre ~ tx)
lmod
as.numeric(lmod$coef)
as.numeric(lmod$coef)
giulio$OLS <- lmod$coef
giulio$OLS
lmod <- lm(yv.pre ~ tx - 1)
lmod$coef
lmod <- lm(yv.pre ~ tx)
dim(cbind(1,x.pre))
dimnames(cbind(1,x.pre))
length(sim[1:t0,i])
dimnames(sim)
dim(x)
dim(x.pre)
dim(y)
mean(sim[1:t0,i])
sd(sim[1:t0,i])
apply(cbind(1,x.pre), 1, mean)
apply(cbind(1,x.pre), 2, mean)
apply(cbind(1,x.pre), 2, sd)
hist(rnorm(10000))
??rinvgamma
hist(invgamma::rinvgamma(10000, shape = 1, scale = 3))
mean(invgamma::rinvgamma(10000, shape = 10, scale = 3))
mean(invgamma::rinvgamma(10000, shape = 11, scale = 3))
mean(invgamma::rinvgamma(10000, shape = 11, scale = 3))
mean(invgamma::rinvgamma(10000, shape = 11, scale = 3))
mean(invgamma::rinvgamma(10000, shape = 11, scale = 3))
mean(invgamma::rinvgamma(10000, shape = 11, scale = 5))
5 / 10
mean(invgamma::rinvgamma(10000, shape = 11, scale = 1/5))
mean(MCMCpack::rinvgamma(1000, 11, 3))
mean(MCMCpack::rinvgamma(1000, 11, 5))
??MCMCpack::rinvgamma
hist(MCMCpack::rinvgamma(10000, 1, 1))
hist(MCMCpack::rinvgamma(10000, 11, 5))
hist(MCMCpack::rinvgamma(10000, 5, 3))
mean(MCMCpack::rinvgamma(10000, 5, 3))
sd(MCMCpack::rinvgamma(10000, 5, 3))
hist(MCMCpack::rinvgamma(10000, 5, 3), breaks = 30)
hist(MCMCpack::rinvgamma(10000, 3, 3), breaks = 30)
hist(MCMCpack::rinvgamma(10000, 4, 3), breaks = 30)
hist(MCMCpack::rinvgamma(10000, 4, 2), breaks = 30)
hist(MCMCpack::rinvgamma(10000, 4, 3), breaks = 30)
hist(MCMCpack::rinvgamma(10000, 4, 3), breaks = 50)
hist(MCMCpack::rinvgamma(10000, 4, 3), breaks = 100)
abline(v = 1)
abline(v = 1, col = 'red')
hist(MCMCpack::rinvgamma(10000, 4, 2), breaks = 100)
abline(v = 1, col = 'red')
mean(MCMCpack::rinvgamma(10000, 4, 2) < 1)
lista_par=list()
for (i in 1:bands){
ss_data = list(
x = cbind(1,x.pre),
y = sim[1:t0,i],
N = t0,
C = num_controls+1,
X_new=cbind(1,x),
N_new=nrow(x)
)
fit <- rstan::stan(
file = "replication_april/bayesian_vr.stan",
data = ss_data,
cores = 3,
iter = iter,
chains = 3,
verbose = F,
warmup = warm,
control = list(
max_treedepth = 12,
stepsize = 0.05,
adapt_delta = 0.85
)
)
lista_par[[i]] <- rstan::extract(fit)
}
for (i in 1:bands){
ss_data = list(
x = cbind(1,x.pre),
y = sim[1:t0,i],
N = t0,
C = num_controls+1,
X_new=cbind(1,x),
N_new=nrow(x)
)
fit <- rstan::stan(
file = "bayesian_vr.stan",
data = ss_data,
cores = 3,
iter = iter,
chains = 3,
verbose = F,
warmup = warm,
control = list(
max_treedepth = 12,
stepsize = 0.05,
adapt_delta = 0.85
)
)
lista_par[[i]] <- rstan::extract(fit)
}
library(rstan)
for (i in 1:bands){
ss_data = list(
x = cbind(1,x.pre),
y = sim[1:t0,i],
N = t0,
C = num_controls+1,
X_new=cbind(1,x),
N_new=nrow(x)
)
fit <- rstan::stan(
file = "bayesian_vr.stan",
data = ss_data,
cores = 3,
iter = iter,
chains = 3,
verbose = F,
warmup = warm,
control = list(
max_treedepth = 12,
stepsize = 0.05,
adapt_delta = 0.85
)
)
lista_par[[i]] <- rstan::extract(fit)
}
for (i in 1:bands){
ss_data = list(
x = cbind(1,x.pre),
y = sim[1:t0,i],
N = t0,
C = num_controls+1,
X_new=cbind(1,x),
N_new=nrow(x)
)
fit <- rstan::stan(
file = "bayesian_vr.stan",
data = ss_data,
cores = 3,
iter = iter,
chains = 3,
verbose = F,
warmup = warm,
control = list(
max_treedepth = 12,
stepsize = 0.05,
adapt_delta = 0.85
)
)
lista_par[[i]] <- rstan::extract(fit)
}
names(giulio)
length(lista_par)
bands
class(lista_par[[1]])
names(lista_par[[1]])
names(list_par)
names(lista_par)
names(lista_par) <- paste('treated', 1 : bands)
class(lista_par$`treated 1`$sigma_sq)
dim(lista_par$`treated 1`$sigma_sq)
iter
warm
plot(lista_par$`treated 1`$sigma_sq, type = 'l')
dim(lista_par$`treated 1`$gp1)
plot(lista_par$`treated 1`$gp1[, 1], type = 'l')
plot(lista_par$`treated 1`$gp1[, 2], type = 'l')
plot(lista_par$`treated 1`$gp1[, 3], type = 'l')
apply(lista_par$`treated 1`$gp, 2, mean)
apply(lista_par$`treated 1`$gp, 2, sd)
names(lista_par$`treated 1`)
dim(lista_par$`treated 1`$y_new)
giulio$BVR <- lista_par
plot(lista_par$`treated 1`$sigma, sqrt(lista_par$`treated 1`$sigma_sq))
abline(a = 0, b= )
abline(a = 0, b= 1)
method
lista_par=list()
for (i in 1:bands) {
ss_data = list(
x = x.pre,
y = sim[1:t0,i],
N = t0,
C = num_controls,
X_new=x,
N_new=nrow(x)
)
fit <- rstan::stan(
file = "replication_april/bayes_sc.stan",
data = ss_data,
cores = 3,
iter = iter,
chains = 3,
verbose = F,
warmup = warm,
control = list(
max_treedepth = 12,
stepsize = 0.05,
adapt_delta = 0.85
)
)
lista_par[[i]] <- rstan::extract(fit)
}
lista_par=list()
for (i in 1:bands) {
ss_data = list(
x = x.pre,
y = sim[1:t0,i],
N = t0,
C = num_controls,
X_new=x,
N_new=nrow(x)
)
fit <- rstan::stan(
file = "bayes_sc.stan",
data = ss_data,
cores = 3,
iter = iter,
chains = 3,
verbose = F,
warmup = warm,
control = list(
max_treedepth = 12,
stepsize = 0.05,
adapt_delta = 0.85
)
)
lista_par[[i]] <- rstan::extract(fit)
}
names(lista_par) <- paste('treated', 1 : bands)
names(lista_par)
names(lista_par$`treated 1`)
plot(lista_par$`treated 1`$sigma)
plot(lista_par$`treated 1`$gp1[, 1], type = 'l')
plot(lista_par$`treated 1`$gp1[, 2], type = 'l')
plot(lista_par$`treated 1`$gp1[, 3], type = 'l')
dim(lista_par$`treated 1`$gp1)
dim(lista_par$`treated 1`$y_new)
giulio$BSC <- lista_par
identical(cbind(1,sim[1:t0,(bands+1):(bands+num_controls)]), x.pre)
dim(cbind(1,sim[1:t0,(bands+1):(bands+num_controls)]))
dim(x.pre)
dim(sim[1:t0,1:bands])
dim(ym.pre)
identical(sim[1:t0,1:bands], ym.pre)
identical(cbind(1,sim[1:t0,(bands+1):(bands+num_controls)]), cbind(1, x.pre))
identical(cbind(1, sim[,(bands+1):(bands+num_controls)]), cbind(1, x))
rm(list = ls())
sp_range = 0.3
tt_periods = 10
tt_periods = 13
errors_sp = 2
index = 1
set.seed(index)
puppi=index
setwd('~/Documents/Research/Students/Giulio/Sims_Aug2024/')
# Sourcing in code from other files.
source("sim_july.R")
source("preset.R")
# Function for performing synthetic controls.
source ("Functions/synth.R")
# Functions for performing the pooled ridge.
source("Functions/tcv_ridge.R")
source("Functions/x_matrix.R")
source("Functions/ridge.R")
# Functions for performing fused ridge.
source("Functions/fused.R")
source("Functions/tcv_fused.R")
library(LowRankQP)
library(glmnet)
library(rstan)
num_controls = 7
t0=tt_periods
time_periods=t0 + 20
time_periods_controls <- 80  # -GP- Do not change this with t0.
bands = 11
## sampling pars
iter=6000
warm=2000
sp_var=.4
tt_var=0.3 ^ 2  # -GP- I reduced the tt_var a little.
ti_var=0.7 ^ 2  # -GP- I squared this to make it a variance and comparable to tt_var
bi_var=0.5 ^ 2  # -GP- I squared this to make it a variance and comparable to sp_var
tt_range=.05
sp_nugget=0.001
tt_nugget=0.15 ^ 2  # -GP- Adding some temporal nugget to the controls.
rho_error=.2
## errors def
seed_b=seed_t=seed_e=index
if(errors_sp==1){
e_weight=0  # Proportion of error that is spatial
share_error=0.4  # Noise-signal ratio (sd for error term as % of signal)
} else if(errors_sp==2){
e_weight=.5
share_error=0.4
} else if(errors_sp==3){
e_weight=.5
share_error=0.7 # -GG- : corrected mistake (21/08)
}
print(errors_sp)
#error=sqrt(.55)
#treated_radius = sort(scale(runif(bands, 0.01, 1)))
treated_radius <- seq(0, 1, length.out = bands)
treated_radius= treated_radius/max(treated_radius)
## store results over loop
method=c("SC","SR","PR", "BVR","BSC","MGP")
print(treated_radius)
sim=sim_model(seed_b = seed_b, seed_t = seed_t, seed_e = seed_e,
time_periods = time_periods, time_periods_controls = time_periods_controls,
bands = bands, num_controls = num_controls,
sp_var = sp_var, sp_range = sp_range, bi_var = bi_var, tt_var = tt_var,
tt_range = tt_range, ti_var = ti_var, sp_nugget = sp_nugget,
tt_nugget = tt_nugget,
e_weight = e_weight, share_error = share_error)
beta_true=sim$beta
sim=sim$sim  # The potential outcomes under control.
plot(beta[, 1], type = 'l')
plot(beta_true[, 1], type = 'l')
plot(sim[, 1], type = 'l')
plot(sim[, bands + 1], type = 'l')
bands
dim(sim)
dim(sim)
tt_periods
beta_true=sim$beta
sim=sim_model(seed_b = seed_b, seed_t = seed_t, seed_e = seed_e,
time_periods = time_periods, time_periods_controls = time_periods_controls,
bands = bands, num_controls = num_controls,
sp_var = sp_var, sp_range = sp_range, bi_var = bi_var, tt_var = tt_var,
tt_range = tt_range, ti_var = ti_var, sp_nugget = sp_nugget,
tt_nugget = tt_nugget,
e_weight = e_weight, share_error = share_error)
beta_true=sim$beta
sim=sim$sim  # The potential outcomes under control.
set.seed(index)
est = estimation_mode(sim = sim, t0 = t0, bands = bands, iter = iter, warm = warm,
norm = T, method = method)
source("est_mode.R")
est = estimation_mode(sim = sim, t0 = t0, bands = bands, iter = iter, warm = warm,
norm = T, method = method)
set.seed(index)
est = estimation_mode(sim = sim, t0 = t0, bands = bands, iter = iter, warm = warm,
norm = T, method = method)

upper[,i] <- apply(posterior$ynn[,,i],2,0.975)
store=cbind(store, loc)
}
loc=list(lower, upper)
names(loc)=c("lower_bound","upper_bound")
out$SMAC=loc
}
library(purrr)
out=compact(out)
names(out)=names(est)
return(out)
}
ci= ci_function(sim=sim, est=est, cal=cal, norm = T)
ci$BSC$upper_bound
ci$SC$upper_bound
if ("BVR" %in% names(est)){
up=matrix(nrow=time_periods, ncol=bands)
low=matrix(nrow=time_periods, ncol=bands)
mse=matrix(nrow=time_periods, ncol=bands)
for(i in 1:bands){
ff=est[["BVR"]][[i]]$y_new
for(hh in 1:nrow(ff)){
ff[hh,]=(ff[hh,]*scale[i])+center[i]
}
up[,i]=apply(ff,2,quantile, p=0.975)
low[,i]=apply(ff,2,quantile, p=0.025)
loc=(sweep(ff, 2, sim[,i]))^2
mse[,i]=apply(loc,2,median)
}
bvr=list(up,low, mse)
}
up=matrix(nrow=time_periods, ncol=bands)
low=matrix(nrow=time_periods, ncol=bands)
mse=matrix(nrow=time_periods, ncol=bands)
ff=est[["BVR"]][[i]]$y_new
for(hh in 1:nrow(ff)){
ff[hh,]=(ff[hh,]*sds[i])+means[i]
}
up[,i]=apply(ff,2,quantile, p=0.975)
low[,i]=apply(ff,2,quantile, p=0.025)
up
low
dim(ff)
method="BSC"
loc <- est[[method]][[i]]$y_new
LOC
loc
lower[,i]<-apply(loc,2,quantile, prob=0.025)
upper[,i]<-apply(loc,2,quantile, prob=0.975)
lower=matrix(nrow=time_periods, ncol=bands)
upper=matrix(nrow=time_periods, ncol=bands)
loc <- est[[method]][[i]]$y_new
lower[,i]<-apply(loc,2,quantile, prob=0.025)
upper[,i]<-apply(loc,2,quantile, prob=0.975)
lower
upper
loc <- est[[method]][[i]]$y_new
for(hh in 1:nrow(loc)){
loc[hh,]=(loc[hh,]*sds[i])+means[i]
}
lower[,i]<-apply(loc,2,quantile, prob=0.025)
upper[,i]<-apply(loc,2,quantile, prob=0.975)
upper
sds
means
sim_std$means
sim
index
sim=sim_model(seed_b = seed_b, seed_t = seed_t, seed_e = seed_e,
time_periods = time_periods,
time_periods_controls = time_periods_controls,
bands = bands, num_controls = num_controls,
sp_var = sp_var, sp_range = sp_range, bi_var = bi_var,
tt_var = tt_var,
tt_range = tt_range, ti_var = ti_var, sp_nugget = sp_nugget,
tt_nugget = tt_nugget,
e_weight = e_weight, share_error = share_error)
sim=sim$sim  # The potential outcomes under control.
norm=T
if (norm == T) {
sim_std <- preset(sim, t0)
sim <- sim_std$std
means <- sim_std$means
sds <- sim_std$sds
}
means
sds
lower=matrix(nrow=time_periods, ncol=bands)
upper=matrix(nrow=time_periods, ncol=bands)
loc <- est[[method]][[i]]$y_new
lower[,i]<-apply(loc,2,quantile, prob=0.025)
upper[,i]<-apply(loc,2,quantile, prob=0.975)
upper[,1]
loc <- est[[method]][[i]]$y_new
for(hh in 1:nrow(loc)){
loc[hh,]=(loc[hh,]*sds[i])+means[i]
}
lower[,i]<-apply(loc,2,quantile, prob=0.025)
upper[,i]<-apply(loc,2,quantile, prob=0.975)
upper[,1]
ci_bayes <- function(sim, est, method, norm){
if (norm == T) {
sim_std <- preset(sim, t0)
sim <- sim_std$std
means <- sim_std$means
sds <- sim_std$sds
}
lower=matrix(nrow=time_periods, ncol=bands)
upper=matrix(nrow=time_periods, ncol=bands)
for(i in 1:bands){
loc <- est[[method]][[i]]$y_new
for(hh in 1:nrow(loc)){
loc[hh,]=(loc[hh,]*sds[i])+means[i]
}
lower[,i]<-apply(loc,2,quantile, prob=0.025)
upper[,i]<-apply(loc,2,quantile, prob=0.975)
}
out=list(lower, upper)
names(out)=c("lower_bound","upper_bound" )
return(out)
}
ci= ci_function(sim=sim, est=est, cal=cal, norm = T)
ci$SC[,1]
ci$SC$upper_bound[,1]
ci$BSC$upper_bound[,1]
ci_bayes <- function(sim, est, method, norm){
if (norm == T) {
sim_std <- preset(sim, t0)
sim <- sim_std$std
means <- sim_std$means
sds <- sim_std$sds
}
lower=matrix(nrow=time_periods, ncol=bands)
upper=matrix(nrow=time_periods, ncol=bands)
for(i in 1:bands){
loc <- est[[method]][[i]]$y_new
for(hh in 1:nrow(loc)){
loc[hh,]=(loc[hh,]*sds[i])+means[i]
}
lower[,i]<-apply(loc,2,quantile, prob=0.025)
upper[,i]<-apply(loc,2,quantile, prob=0.975)
}
out=list(lower, upper)
names(out)=c("lower_bound","upper_bound" )
return(out)
}
sim=sim_model(seed_b = seed_b, seed_t = seed_t, seed_e = seed_e,
time_periods = time_periods,
time_periods_controls = time_periods_controls,
bands = bands, num_controls = num_controls,
sp_var = sp_var, sp_range = sp_range, bi_var = bi_var,
tt_var = tt_var,
tt_range = tt_range, ti_var = ti_var, sp_nugget = sp_nugget,
tt_nugget = tt_nugget,
e_weight = e_weight, share_error = share_error)
sim=sim$sim  # The potential outcomes under control.
ci= ci_function(sim=sim, est=est, cal=cal, norm = T)
ci$SC$upper_bound[,1]
ci$BSC$upper_bound[,1]
est = estimation(sim = sim, t0 = t0, bands = bands, iter = iter, warm = warm,
norm = T, method = method)
est
sim=sim_model(seed_b = seed_b, seed_t = seed_t, seed_e = seed_e,
time_periods = time_periods,
time_periods_controls = time_periods_controls,
bands = bands, num_controls = num_controls,
sp_var = sp_var, sp_range = sp_range, bi_var = bi_var,
tt_var = tt_var,
tt_range = tt_range, ti_var = ti_var, sp_nugget = sp_nugget,
tt_nugget = tt_nugget,
e_weight = e_weight, share_error = share_error)
beta_true=sim$beta
sim=sim$sim  # The potential outcomes under control.
ci= ci_function(sim=sim, est=est, cal=cal, norm = T)
ci$SC[,1]
ci$SC$upper_bound[,1]
ci$BSC$upper_bound[,1]
sim=sim_model(seed_b = seed_b, seed_t = seed_t, seed_e = seed_e,
time_periods = time_periods,
time_periods_controls = time_periods_controls,
bands = bands, num_controls = num_controls,
sp_var = sp_var, sp_range = sp_range, bi_var = bi_var,
tt_var = tt_var,
tt_range = tt_range, ti_var = ti_var, sp_nugget = sp_nugget,
tt_nugget = tt_nugget,
e_weight = e_weight, share_error = share_error)
beta_true=sim$beta
sim=sim$sim  # The potential outcomes under control.
sim[,1]
cal$BSC
cal$BSC[,1]
sim[,1]
ci_function<-function(sim, est, cal, norm){
# Standardizing the data using the preset function.
# if (norm == T) {
#   sim_std <- preset(sim, t0)
#   sim <- sim_std$std
#   means <- sim_std$means
#   sds <- sim_std$sds
# }
out=list()
### 1.0 SEPARATED SCM
if ("SC" %in% names(cal)){
bands=ncol(cal$SC)
true=sim[,1:bands]
estimate=cal$SC
out$SC=ci_shen(true, estimate)
}
### 2.0 SEPARATED VERTICAL REGRESSION WITH RIDGE PEN
if ("SR" %in% names(cal)){
bands=ncol(cal$SR)
true=sim[,1:bands]
estimate=cal$SR
out$SR=ci_shen(true, estimate)
}
### 3.0 MULTIVARIATE OLS
if ("OLS" %in% names(cal)){
bands=ncol(cal$OLS)
true=sim[,1:bands]
estimate=cal$OLS
out$OLS=ci_shen(true, estimate)
}
### 4.0 BAYESIAN VERTICAL REGRESSION
if ("BVR" %in% names(est)){
time_periods<-nrow(sim)
bands<-ncol(cal$BVR)
out$BVR <- ci_bayes(sim, est, "BSC", norm)
}
### 5.0 BAYESIAN SYNTHETIC CONTROL
if ("BSC" %in% names(est)){
time_periods<-nrow(sim)
bands<-ncol(cal$BSC)
out$BSC <- ci_bayes(sim, est, "BSC", norm)
}
### 6.0 SMAC
if ("SMAC" %in% names(est)){
posterior=rstan::extract(est[["SMAC"]])
time_periods<-nrow(sim)
bands<-ncol(cal$BSC)
lower=matrix(nrow=time_periods, ncol=bands)
upper=matrix(nrow=time_periods, ncol=bands)
for(i in 1:bands){
lower[,i] <- apply(posterior$ynn[,,i],2,0.025)
upper[,i] <- apply(posterior$ynn[,,i],2,0.975)
store=cbind(store, loc)
}
loc=list(lower, upper)
names(loc)=c("lower_bound","upper_bound")
out$SMAC=loc
}
library(purrr)
out=compact(out)
names(out)=names(est)
return(out)
}
ci= ci_function(sim=sim, est=est, cal=cal, norm = T)
ci$BSC$upper_bound
coverage<-function(true, down, up){
loc <- vector(length = length(true))
bands <- ncol(down)
time_periods <- nrow(true)
loc <- matrix(nrow=time_periods, ncol=bands)
for(ii in 1:bands){
for (tt in 1:time_periods){
loc[tt, ii]=true[tt, ii]<up[tt, ii] && true[tt, ii]>down[tt, ii]
}
}
return(loc)
}
coverage(sim[,1:bands], ci$SC$lower_bound, ci$SC$upper_bound)
prova<-coverage(sim[,1:bands], ci$SC$lower_bound, ci$SC$upper_bound)
apply(prova, 2, mean)
apply(prova, 1, mean)
plot(apply(prova, 1, mean))
as.numeric(prova)
as.numeric(matrix(prova))
as.numeric(matrix(prova, nrow=time_perioda))
as.numeric(matrix(prova, nrow=time_periods))
loc=matrix(as.numeric(loc), nrow=time_periods, ncol=bands)
coverage<-function(true, down, up){
loc <- vector(length = length(true))
bands <- ncol(down)
time_periods <- nrow(true)
loc <- matrix(nrow=time_periods, ncol=bands)
for(ii in 1:bands){
for (tt in 1:time_periods){
loc[tt, ii]=true[tt, ii]<up[tt, ii] && true[tt, ii]>down[tt, ii]
}
}
loc=matrix(as.numeric(loc), nrow=time_periods, ncol=bands)
return(loc)
}
coverage(sim[,1:bands], ci$SC$lower_bound, ci$SC$upper_bound)
ci$SC$upper_bound
###############################################################################
######################### COVERAGE ESTIMATION ######################
###############################################################################
## @ sim <- data or simulation matrix
## @ CI <- confidence intervals
## Preparing different matrix config for estimation
#  pre/post treatment
ci_function<-function(sim, ci){
bands=ncol(ci$SC$upper_bound)
time_periods=nrow(ci$SC$upper_bound)
out=list()
### 1.0 SEPARATED SCM
if ("SC" %in% names(ci)){
out$SC <- coverage(sim[,1:bands],
ci$SC$lower_bound, ci$SC$upper_bound)
}
### 2.0 SEPARATED VERTICAL REGRESSION WITH RIDGE PEN
if ("SR" %in% names(ci)){
out$SR <- coverage(sim[,1:bands],
ci$SR$lower_bound, ci$SR$upper_bound)
}
### 3.0 MULTIVARIATE OLS
if ("OLS" %in% names(ci)){
out$OLS <- coverage(sim[,1:bands],
ci$OLS$lower_bound, ci$OLS$upper_bound)
}
### 4.0 BAYESIAN VERTICAL REGRESSION
if ("BVR" %in% names(ci)){
out$BVR <- coverage(sim[,1:bands],
ci$BVR$lower_bound, ci$BVR$upper_bound)
}
### 5.0 BAYESIAN SYNTHETIC CONTROL
if ("BSC" %in% names(ci)){
out$BSC <- coverage(sim[,1:bands],
ci$BSC$lower_bound, ci$BSC$upper_bound)
}
### 6.0 SMAC
if ("SMAC" %in% names(ci)){
out$SMAC <- coverage(sim[,1:bands],
ci$SMAC$lower_bound, ci$SMAC$upper_bound)
}
library(purrr)
out=compact(out)
names(out)=names(est)
return(out)
}
coverage<-coverage_function(sim, ci)
coverage_function<-function(sim, ci){
bands=ncol(ci$SC$upper_bound)
time_periods=nrow(ci$SC$upper_bound)
out=list()
### 1.0 SEPARATED SCM
if ("SC" %in% names(ci)){
out$SC <- coverage(sim[,1:bands],
ci$SC$lower_bound, ci$SC$upper_bound)
}
### 2.0 SEPARATED VERTICAL REGRESSION WITH RIDGE PEN
if ("SR" %in% names(ci)){
out$SR <- coverage(sim[,1:bands],
ci$SR$lower_bound, ci$SR$upper_bound)
}
### 3.0 MULTIVARIATE OLS
if ("OLS" %in% names(ci)){
out$OLS <- coverage(sim[,1:bands],
ci$OLS$lower_bound, ci$OLS$upper_bound)
}
### 4.0 BAYESIAN VERTICAL REGRESSION
if ("BVR" %in% names(ci)){
out$BVR <- coverage(sim[,1:bands],
ci$BVR$lower_bound, ci$BVR$upper_bound)
}
### 5.0 BAYESIAN SYNTHETIC CONTROL
if ("BSC" %in% names(ci)){
out$BSC <- coverage(sim[,1:bands],
ci$BSC$lower_bound, ci$BSC$upper_bound)
}
### 6.0 SMAC
if ("SMAC" %in% names(ci)){
out$SMAC <- coverage(sim[,1:bands],
ci$SMAC$lower_bound, ci$SMAC$upper_bound)
}
library(purrr)
out=compact(out)
names(out)=names(est)
return(out)
}
coverage<-coverage_function(sim, ci)
coverage$SC
coverage$SR
coverage$BSC
coverage$BVR
source("Functions/sim_model_function.R")
source("Functions/estimation_function.R")
source("Functions/calculation_function.R")
source("Functions/point_estimate_function.R")
source("Functions/ci_function.R")
source("Functions/coverage_function.R")
source("Methods/helper/preset_function.R")
source("Methods/helper/ci_shen.R")
source("Methods/helper/ci_bayes.R")
source("Methods/helper/coverage.R")
wrap <- function(spatial_range){
s1 <- spatial_range
for (ss in s1){
for (tt in c(10, 20, 40)){
for (ee in c(1,2,3)){
simulations =list()
calculations=list()
point_estimates = list()
confidence_intervals = list()
coverage = list()
active=as.vector(list.files(paste0("Output/apr_sims/Results","/ss",ss,
"/tt", tt, "/ee", ee)))
for(hh in 1:length(active)){
tryCatch({
ii=active[hh]
load(paste0('Output/apr_sims/Results',"/ss",ss, "/tt", tt,
"/ee", ee, "/", ii))
hh=which(active==ii)
simulations[[hh]]<-res[[1]]
calculations[[hh]]<-res[[3]]
point_estimates[[hh]]<-res[[5]]
confidence_intervals[[hh]]<-res[[6]]
coverage <- res[[7]]
}, error = function(e) {
# Gestione dell'errore
print(paste("Errore durante l'iterazione", i, ": ", e$message))
})
}
## - save simulations
save_file=paste0("Output/apr_sims/sim.", "ss",ss, "tt", tt,"ee",
ee, ".RData")
print(save_file)
save(simulations, file =save_file)
##- save calculations
save_file=paste0("Output/apr_sims/cal.", "ss",ss, "tt", tt, "ee",
ee,  ".RData")
save(calculations, file =save_file)
## save point estimates
save_file=paste0("Output/apr_sims/point.", "ss",ss, "tt", tt, "ee",
ee,  ".RData")
save(point_estimates, file =save_file)
## save confidence intervals
save_file=paste0("Output/apr_sims/ci.", "ss",ss, "tt", tt, "ee",
ee,  ".RData")
save(confidence_intervals, file =save_file)
## save confidence intervals
save_file=paste0("Output/apr_sims/cov.", "ss",ss, "tt", tt, "ee",
ee,  ".RData")
save(coverage, file =save_file)
}
}
}
}
point_est()
Q
point
point = point_est(sim,cal) ## it calculates bias and MSE
methods
method
methods=c("SC", "SR")
rr <- list()
for(ii in 1:lenght(methods)){
rr$methods[1]=list()
}
for(ii in 1:length(methods)){
rr$methods[1]=list()
}
rr
rr <- list()
for(ii in 1:length(methods)){
rr$methods[ii]=list()
}
rr
rr$methods[ii]
rr$SC=1
rr$SC
for(ii in 1:length(methods)){
rr[[ii]]=list()
}
rr
names(rr)=methods
rr
i=1
rr$methods[i]
coverage<-coverage_function(sim, ci)
coverage$SC
post_treatment
tt0=c(rep(10,3), rep(20, 3), rep(40,3))
pt1=rep(5,9)
pt2=rep(10,9)
pt3=c(rep(5,3), rep(10, 3), rep(20,3))
tt0
pt1
pt2
pt3
cal
cal[[1]]
tabler<-function(res, tt0, post_treatment){
tab=vector()
nn=c("tt10 - IID", "tt10 - 40%", "tt10 - 70%",
"tt20 - IID", "tt20 - 40%", "tt20 - 70%",
"tt40 - IID", "tt40 - 40%", "tt40 - 70%"  )
tavola=vector()
for (ii in 1:length(input$SMAC)){
t0=tt0[ii]
time_periods=tt0[ii] + post_treatment[ii]
loc <- res[[ii]]
tab=vector()
for (kk in 1:length(loc)){
tab<-c(tab, mean(apply(loc[[kk]], 1, mean)[(t0+1):time_periods], na.rm=T))
}
colnames(tab)=colnames(loc)
tavola=rbind(tavola, tab)
}
rownames(tavola) = nn
out(tavola)
}
